// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: util/proto/warp_msg.proto

#ifndef PROTOBUF_util_2fproto_2fwarp_5fmsg_2eproto__INCLUDED
#define PROTOBUF_util_2fproto_2fwarp_5fmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "util/proto/util.pb.h"
#include "db/proto/db.pb.h"
#include "parse/proto/parser_config.pb.h"
// @@protoc_insertion_point(includes)

namespace hotbox {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_util_2fproto_2fwarp_5fmsg_2eproto();
void protobuf_AssignDesc_util_2fproto_2fwarp_5fmsg_2eproto();
void protobuf_ShutdownFile_util_2fproto_2fwarp_5fmsg_2eproto();

class ClientHandshake;
class ClientMsg;
class CloseSessionReq;
class CreateDBReq;
class CreateSessionReply;
class CreateSessionReq;
class DBServerShutdownReq;
class GenericReply;
class GenericRequest;
class ReadFileReq;
class ServerHandshake;
class ServerMsg;

// ===================================================================

class ClientMsg : public ::google::protobuf::Message {
 public:
  ClientMsg();
  virtual ~ClientMsg();

  ClientMsg(const ClientMsg& from);

  inline ClientMsg& operator=(const ClientMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMsg& default_instance();

  enum MsgCase {
    kHandshakeMsg = 1,
    kGenericReq = 2,
    kCreateDbReq = 3,
    kReadFileReq = 4,
    kDbServerShutdownReq = 5,
    kCreateSessionReq = 6,
    kCloseSessionReq = 7,
    MSG_NOT_SET = 0,
  };

  void Swap(ClientMsg* other);

  // implements Message ----------------------------------------------

  inline ClientMsg* New() const { return New(NULL); }

  ClientMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMsg& from);
  void MergeFrom(const ClientMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hotbox.ClientHandshake handshake_msg = 1;
  bool has_handshake_msg() const;
  void clear_handshake_msg();
  static const int kHandshakeMsgFieldNumber = 1;
  const ::hotbox::ClientHandshake& handshake_msg() const;
  ::hotbox::ClientHandshake* mutable_handshake_msg();
  ::hotbox::ClientHandshake* release_handshake_msg();
  void set_allocated_handshake_msg(::hotbox::ClientHandshake* handshake_msg);

  // optional .hotbox.GenericRequest generic_req = 2;
  bool has_generic_req() const;
  void clear_generic_req();
  static const int kGenericReqFieldNumber = 2;
  const ::hotbox::GenericRequest& generic_req() const;
  ::hotbox::GenericRequest* mutable_generic_req();
  ::hotbox::GenericRequest* release_generic_req();
  void set_allocated_generic_req(::hotbox::GenericRequest* generic_req);

  // optional .hotbox.CreateDBReq create_db_req = 3;
  bool has_create_db_req() const;
  void clear_create_db_req();
  static const int kCreateDbReqFieldNumber = 3;
  const ::hotbox::CreateDBReq& create_db_req() const;
  ::hotbox::CreateDBReq* mutable_create_db_req();
  ::hotbox::CreateDBReq* release_create_db_req();
  void set_allocated_create_db_req(::hotbox::CreateDBReq* create_db_req);

  // optional .hotbox.ReadFileReq read_file_req = 4;
  bool has_read_file_req() const;
  void clear_read_file_req();
  static const int kReadFileReqFieldNumber = 4;
  const ::hotbox::ReadFileReq& read_file_req() const;
  ::hotbox::ReadFileReq* mutable_read_file_req();
  ::hotbox::ReadFileReq* release_read_file_req();
  void set_allocated_read_file_req(::hotbox::ReadFileReq* read_file_req);

  // optional .hotbox.DBServerShutdownReq db_server_shutdown_req = 5;
  bool has_db_server_shutdown_req() const;
  void clear_db_server_shutdown_req();
  static const int kDbServerShutdownReqFieldNumber = 5;
  const ::hotbox::DBServerShutdownReq& db_server_shutdown_req() const;
  ::hotbox::DBServerShutdownReq* mutable_db_server_shutdown_req();
  ::hotbox::DBServerShutdownReq* release_db_server_shutdown_req();
  void set_allocated_db_server_shutdown_req(::hotbox::DBServerShutdownReq* db_server_shutdown_req);

  // optional .hotbox.CreateSessionReq create_session_req = 6;
  bool has_create_session_req() const;
  void clear_create_session_req();
  static const int kCreateSessionReqFieldNumber = 6;
  const ::hotbox::CreateSessionReq& create_session_req() const;
  ::hotbox::CreateSessionReq* mutable_create_session_req();
  ::hotbox::CreateSessionReq* release_create_session_req();
  void set_allocated_create_session_req(::hotbox::CreateSessionReq* create_session_req);

  // optional .hotbox.CloseSessionReq close_session_req = 7;
  bool has_close_session_req() const;
  void clear_close_session_req();
  static const int kCloseSessionReqFieldNumber = 7;
  const ::hotbox::CloseSessionReq& close_session_req() const;
  ::hotbox::CloseSessionReq* mutable_close_session_req();
  ::hotbox::CloseSessionReq* release_close_session_req();
  void set_allocated_close_session_req(::hotbox::CloseSessionReq* close_session_req);

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:hotbox.ClientMsg)
 private:
  inline void set_has_handshake_msg();
  inline void set_has_generic_req();
  inline void set_has_create_db_req();
  inline void set_has_read_file_req();
  inline void set_has_db_server_shutdown_req();
  inline void set_has_create_session_req();
  inline void set_has_close_session_req();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union MsgUnion {
    MsgUnion() {}
    ::hotbox::ClientHandshake* handshake_msg_;
    ::hotbox::GenericRequest* generic_req_;
    ::hotbox::CreateDBReq* create_db_req_;
    ::hotbox::ReadFileReq* read_file_req_;
    ::hotbox::DBServerShutdownReq* db_server_shutdown_req_;
    ::hotbox::CreateSessionReq* create_session_req_;
    ::hotbox::CloseSessionReq* close_session_req_;
  } msg_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_AssignDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_util_2fproto_2fwarp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static ClientMsg* default_instance_;
};
// -------------------------------------------------------------------

class ServerMsg : public ::google::protobuf::Message {
 public:
  ServerMsg();
  virtual ~ServerMsg();

  ServerMsg(const ServerMsg& from);

  inline ServerMsg& operator=(const ServerMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMsg& default_instance();

  enum MsgCase {
    kHandshakeMsg = 1,
    kGenericReply = 2,
    kCreateSessionReply = 3,
    MSG_NOT_SET = 0,
  };

  void Swap(ServerMsg* other);

  // implements Message ----------------------------------------------

  inline ServerMsg* New() const { return New(NULL); }

  ServerMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerMsg& from);
  void MergeFrom(const ServerMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hotbox.ServerHandshake handshake_msg = 1;
  bool has_handshake_msg() const;
  void clear_handshake_msg();
  static const int kHandshakeMsgFieldNumber = 1;
  const ::hotbox::ServerHandshake& handshake_msg() const;
  ::hotbox::ServerHandshake* mutable_handshake_msg();
  ::hotbox::ServerHandshake* release_handshake_msg();
  void set_allocated_handshake_msg(::hotbox::ServerHandshake* handshake_msg);

  // optional .hotbox.GenericReply generic_reply = 2;
  bool has_generic_reply() const;
  void clear_generic_reply();
  static const int kGenericReplyFieldNumber = 2;
  const ::hotbox::GenericReply& generic_reply() const;
  ::hotbox::GenericReply* mutable_generic_reply();
  ::hotbox::GenericReply* release_generic_reply();
  void set_allocated_generic_reply(::hotbox::GenericReply* generic_reply);

  // optional .hotbox.CreateSessionReply create_session_reply = 3;
  bool has_create_session_reply() const;
  void clear_create_session_reply();
  static const int kCreateSessionReplyFieldNumber = 3;
  const ::hotbox::CreateSessionReply& create_session_reply() const;
  ::hotbox::CreateSessionReply* mutable_create_session_reply();
  ::hotbox::CreateSessionReply* release_create_session_reply();
  void set_allocated_create_session_reply(::hotbox::CreateSessionReply* create_session_reply);

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:hotbox.ServerMsg)
 private:
  inline void set_has_handshake_msg();
  inline void set_has_generic_reply();
  inline void set_has_create_session_reply();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union MsgUnion {
    MsgUnion() {}
    ::hotbox::ServerHandshake* handshake_msg_;
    ::hotbox::GenericReply* generic_reply_;
    ::hotbox::CreateSessionReply* create_session_reply_;
  } msg_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_AssignDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_util_2fproto_2fwarp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static ServerMsg* default_instance_;
};
// -------------------------------------------------------------------

class ServerHandshake : public ::google::protobuf::Message {
 public:
  ServerHandshake();
  virtual ~ServerHandshake();

  ServerHandshake(const ServerHandshake& from);

  inline ServerHandshake& operator=(const ServerHandshake& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerHandshake& default_instance();

  void Swap(ServerHandshake* other);

  // implements Message ----------------------------------------------

  inline ServerHandshake* New() const { return New(NULL); }

  ServerHandshake* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerHandshake& from);
  void MergeFrom(const ServerHandshake& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerHandshake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 client_id = 1;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  ::google::protobuf::int32 client_id() const;
  void set_client_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hotbox.ServerHandshake)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 client_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_AssignDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_util_2fproto_2fwarp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static ServerHandshake* default_instance_;
};
// -------------------------------------------------------------------

class ClientHandshake : public ::google::protobuf::Message {
 public:
  ClientHandshake();
  virtual ~ClientHandshake();

  ClientHandshake(const ClientHandshake& from);

  inline ClientHandshake& operator=(const ClientHandshake& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientHandshake& default_instance();

  void Swap(ClientHandshake* other);

  // implements Message ----------------------------------------------

  inline ClientHandshake* New() const { return New(NULL); }

  ClientHandshake* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientHandshake& from);
  void MergeFrom(const ClientHandshake& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientHandshake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool dummy = 1;
  void clear_dummy();
  static const int kDummyFieldNumber = 1;
  bool dummy() const;
  void set_dummy(bool value);

  // @@protoc_insertion_point(class_scope:hotbox.ClientHandshake)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool dummy_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_AssignDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_util_2fproto_2fwarp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static ClientHandshake* default_instance_;
};
// -------------------------------------------------------------------

class GenericRequest : public ::google::protobuf::Message {
 public:
  GenericRequest();
  virtual ~GenericRequest();

  GenericRequest(const GenericRequest& from);

  inline GenericRequest& operator=(const GenericRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GenericRequest& default_instance();

  void Swap(GenericRequest* other);

  // implements Message ----------------------------------------------

  inline GenericRequest* New() const { return New(NULL); }

  GenericRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenericRequest& from);
  void MergeFrom(const GenericRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GenericRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string req = 1;
  void clear_req();
  static const int kReqFieldNumber = 1;
  const ::std::string& req() const;
  void set_req(const ::std::string& value);
  void set_req(const char* value);
  void set_req(const char* value, size_t size);
  ::std::string* mutable_req();
  ::std::string* release_req();
  void set_allocated_req(::std::string* req);

  // @@protoc_insertion_point(class_scope:hotbox.GenericRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr req_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_AssignDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_util_2fproto_2fwarp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static GenericRequest* default_instance_;
};
// -------------------------------------------------------------------

class GenericReply : public ::google::protobuf::Message {
 public:
  GenericReply();
  virtual ~GenericReply();

  GenericReply(const GenericReply& from);

  inline GenericReply& operator=(const GenericReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GenericReply& default_instance();

  void Swap(GenericReply* other);

  // implements Message ----------------------------------------------

  inline GenericReply* New() const { return New(NULL); }

  GenericReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenericReply& from);
  void MergeFrom(const GenericReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GenericReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msg = 1;
  void clear_msg();
  static const int kMsgFieldNumber = 1;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:hotbox.GenericReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_AssignDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_util_2fproto_2fwarp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static GenericReply* default_instance_;
};
// -------------------------------------------------------------------

class CreateDBReq : public ::google::protobuf::Message {
 public:
  CreateDBReq();
  virtual ~CreateDBReq();

  CreateDBReq(const CreateDBReq& from);

  inline CreateDBReq& operator=(const CreateDBReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateDBReq& default_instance();

  void Swap(CreateDBReq* other);

  // implements Message ----------------------------------------------

  inline CreateDBReq* New() const { return New(NULL); }

  CreateDBReq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateDBReq& from);
  void MergeFrom(const CreateDBReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateDBReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hotbox.DBConfig db_config = 1;
  bool has_db_config() const;
  void clear_db_config();
  static const int kDbConfigFieldNumber = 1;
  const ::hotbox::DBConfig& db_config() const;
  ::hotbox::DBConfig* mutable_db_config();
  ::hotbox::DBConfig* release_db_config();
  void set_allocated_db_config(::hotbox::DBConfig* db_config);

  // @@protoc_insertion_point(class_scope:hotbox.CreateDBReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::hotbox::DBConfig* db_config_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_AssignDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_util_2fproto_2fwarp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static CreateDBReq* default_instance_;
};
// -------------------------------------------------------------------

class ReadFileReq : public ::google::protobuf::Message {
 public:
  ReadFileReq();
  virtual ~ReadFileReq();

  ReadFileReq(const ReadFileReq& from);

  inline ReadFileReq& operator=(const ReadFileReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadFileReq& default_instance();

  void Swap(ReadFileReq* other);

  // implements Message ----------------------------------------------

  inline ReadFileReq* New() const { return New(NULL); }

  ReadFileReq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadFileReq& from);
  void MergeFrom(const ReadFileReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadFileReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string db_name = 1;
  void clear_db_name();
  static const int kDbNameFieldNumber = 1;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // optional string file_path = 2;
  void clear_file_path();
  static const int kFilePathFieldNumber = 2;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // optional .hotbox.FileFormat file_format = 3;
  void clear_file_format();
  static const int kFileFormatFieldNumber = 3;
  ::hotbox::FileFormat file_format() const;
  void set_file_format(::hotbox::FileFormat value);

  // optional int32 header = 4;
  void clear_header();
  static const int kHeaderFieldNumber = 4;
  ::google::protobuf::int32 header() const;
  void set_header(::google::protobuf::int32 value);

  // optional .hotbox.ParserConfig parser_config = 5;
  bool has_parser_config() const;
  void clear_parser_config();
  static const int kParserConfigFieldNumber = 5;
  const ::hotbox::ParserConfig& parser_config() const;
  ::hotbox::ParserConfig* mutable_parser_config();
  ::hotbox::ParserConfig* release_parser_config();
  void set_allocated_parser_config(::hotbox::ParserConfig* parser_config);

  // @@protoc_insertion_point(class_scope:hotbox.ReadFileReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  int file_format_;
  ::google::protobuf::int32 header_;
  ::hotbox::ParserConfig* parser_config_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_AssignDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_util_2fproto_2fwarp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static ReadFileReq* default_instance_;
};
// -------------------------------------------------------------------

class DBServerShutdownReq : public ::google::protobuf::Message {
 public:
  DBServerShutdownReq();
  virtual ~DBServerShutdownReq();

  DBServerShutdownReq(const DBServerShutdownReq& from);

  inline DBServerShutdownReq& operator=(const DBServerShutdownReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBServerShutdownReq& default_instance();

  void Swap(DBServerShutdownReq* other);

  // implements Message ----------------------------------------------

  inline DBServerShutdownReq* New() const { return New(NULL); }

  DBServerShutdownReq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBServerShutdownReq& from);
  void MergeFrom(const DBServerShutdownReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DBServerShutdownReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hotbox.DBServerShutdownReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_AssignDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_util_2fproto_2fwarp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static DBServerShutdownReq* default_instance_;
};
// -------------------------------------------------------------------

class CreateSessionReq : public ::google::protobuf::Message {
 public:
  CreateSessionReq();
  virtual ~CreateSessionReq();

  CreateSessionReq(const CreateSessionReq& from);

  inline CreateSessionReq& operator=(const CreateSessionReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionReq& default_instance();

  void Swap(CreateSessionReq* other);

  // implements Message ----------------------------------------------

  inline CreateSessionReq* New() const { return New(NULL); }

  CreateSessionReq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSessionReq& from);
  void MergeFrom(const CreateSessionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateSessionReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hotbox.SessionOptionsProto session_options = 1;
  bool has_session_options() const;
  void clear_session_options();
  static const int kSessionOptionsFieldNumber = 1;
  const ::hotbox::SessionOptionsProto& session_options() const;
  ::hotbox::SessionOptionsProto* mutable_session_options();
  ::hotbox::SessionOptionsProto* release_session_options();
  void set_allocated_session_options(::hotbox::SessionOptionsProto* session_options);

  // @@protoc_insertion_point(class_scope:hotbox.CreateSessionReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::hotbox::SessionOptionsProto* session_options_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_AssignDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_util_2fproto_2fwarp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static CreateSessionReq* default_instance_;
};
// -------------------------------------------------------------------

class CreateSessionReply : public ::google::protobuf::Message {
 public:
  CreateSessionReply();
  virtual ~CreateSessionReply();

  CreateSessionReply(const CreateSessionReply& from);

  inline CreateSessionReply& operator=(const CreateSessionReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionReply& default_instance();

  void Swap(CreateSessionReply* other);

  // implements Message ----------------------------------------------

  inline CreateSessionReply* New() const { return New(NULL); }

  CreateSessionReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSessionReply& from);
  void MergeFrom(const CreateSessionReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateSessionReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msg = 1;
  void clear_msg();
  static const int kMsgFieldNumber = 1;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // optional .hotbox.StatusCode status_code = 2;
  void clear_status_code();
  static const int kStatusCodeFieldNumber = 2;
  ::hotbox::StatusCode status_code() const;
  void set_status_code(::hotbox::StatusCode value);

  // optional .hotbox.SessionProto session_proto = 3;
  bool has_session_proto() const;
  void clear_session_proto();
  static const int kSessionProtoFieldNumber = 3;
  const ::hotbox::SessionProto& session_proto() const;
  ::hotbox::SessionProto* mutable_session_proto();
  ::hotbox::SessionProto* release_session_proto();
  void set_allocated_session_proto(::hotbox::SessionProto* session_proto);

  // @@protoc_insertion_point(class_scope:hotbox.CreateSessionReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::hotbox::SessionProto* session_proto_;
  int status_code_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_AssignDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_util_2fproto_2fwarp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static CreateSessionReply* default_instance_;
};
// -------------------------------------------------------------------

class CloseSessionReq : public ::google::protobuf::Message {
 public:
  CloseSessionReq();
  virtual ~CloseSessionReq();

  CloseSessionReq(const CloseSessionReq& from);

  inline CloseSessionReq& operator=(const CloseSessionReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseSessionReq& default_instance();

  void Swap(CloseSessionReq* other);

  // implements Message ----------------------------------------------

  inline CloseSessionReq* New() const { return New(NULL); }

  CloseSessionReq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseSessionReq& from);
  void MergeFrom(const CloseSessionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CloseSessionReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_id = 1;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // @@protoc_insertion_point(class_scope:hotbox.CloseSessionReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_AssignDesc_util_2fproto_2fwarp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_util_2fproto_2fwarp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static CloseSessionReq* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ClientMsg

// optional .hotbox.ClientHandshake handshake_msg = 1;
inline bool ClientMsg::has_handshake_msg() const {
  return msg_case() == kHandshakeMsg;
}
inline void ClientMsg::set_has_handshake_msg() {
  _oneof_case_[0] = kHandshakeMsg;
}
inline void ClientMsg::clear_handshake_msg() {
  if (has_handshake_msg()) {
    delete msg_.handshake_msg_;
    clear_has_msg();
  }
}
inline  const ::hotbox::ClientHandshake& ClientMsg::handshake_msg() const {
  // @@protoc_insertion_point(field_get:hotbox.ClientMsg.handshake_msg)
  return has_handshake_msg()
      ? *msg_.handshake_msg_
      : ::hotbox::ClientHandshake::default_instance();
}
inline ::hotbox::ClientHandshake* ClientMsg::mutable_handshake_msg() {
  if (!has_handshake_msg()) {
    clear_msg();
    set_has_handshake_msg();
    msg_.handshake_msg_ = new ::hotbox::ClientHandshake;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.ClientMsg.handshake_msg)
  return msg_.handshake_msg_;
}
inline ::hotbox::ClientHandshake* ClientMsg::release_handshake_msg() {
  if (has_handshake_msg()) {
    clear_has_msg();
    ::hotbox::ClientHandshake* temp = msg_.handshake_msg_;
    msg_.handshake_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMsg::set_allocated_handshake_msg(::hotbox::ClientHandshake* handshake_msg) {
  clear_msg();
  if (handshake_msg) {
    set_has_handshake_msg();
    msg_.handshake_msg_ = handshake_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.ClientMsg.handshake_msg)
}

// optional .hotbox.GenericRequest generic_req = 2;
inline bool ClientMsg::has_generic_req() const {
  return msg_case() == kGenericReq;
}
inline void ClientMsg::set_has_generic_req() {
  _oneof_case_[0] = kGenericReq;
}
inline void ClientMsg::clear_generic_req() {
  if (has_generic_req()) {
    delete msg_.generic_req_;
    clear_has_msg();
  }
}
inline  const ::hotbox::GenericRequest& ClientMsg::generic_req() const {
  // @@protoc_insertion_point(field_get:hotbox.ClientMsg.generic_req)
  return has_generic_req()
      ? *msg_.generic_req_
      : ::hotbox::GenericRequest::default_instance();
}
inline ::hotbox::GenericRequest* ClientMsg::mutable_generic_req() {
  if (!has_generic_req()) {
    clear_msg();
    set_has_generic_req();
    msg_.generic_req_ = new ::hotbox::GenericRequest;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.ClientMsg.generic_req)
  return msg_.generic_req_;
}
inline ::hotbox::GenericRequest* ClientMsg::release_generic_req() {
  if (has_generic_req()) {
    clear_has_msg();
    ::hotbox::GenericRequest* temp = msg_.generic_req_;
    msg_.generic_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMsg::set_allocated_generic_req(::hotbox::GenericRequest* generic_req) {
  clear_msg();
  if (generic_req) {
    set_has_generic_req();
    msg_.generic_req_ = generic_req;
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.ClientMsg.generic_req)
}

// optional .hotbox.CreateDBReq create_db_req = 3;
inline bool ClientMsg::has_create_db_req() const {
  return msg_case() == kCreateDbReq;
}
inline void ClientMsg::set_has_create_db_req() {
  _oneof_case_[0] = kCreateDbReq;
}
inline void ClientMsg::clear_create_db_req() {
  if (has_create_db_req()) {
    delete msg_.create_db_req_;
    clear_has_msg();
  }
}
inline  const ::hotbox::CreateDBReq& ClientMsg::create_db_req() const {
  // @@protoc_insertion_point(field_get:hotbox.ClientMsg.create_db_req)
  return has_create_db_req()
      ? *msg_.create_db_req_
      : ::hotbox::CreateDBReq::default_instance();
}
inline ::hotbox::CreateDBReq* ClientMsg::mutable_create_db_req() {
  if (!has_create_db_req()) {
    clear_msg();
    set_has_create_db_req();
    msg_.create_db_req_ = new ::hotbox::CreateDBReq;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.ClientMsg.create_db_req)
  return msg_.create_db_req_;
}
inline ::hotbox::CreateDBReq* ClientMsg::release_create_db_req() {
  if (has_create_db_req()) {
    clear_has_msg();
    ::hotbox::CreateDBReq* temp = msg_.create_db_req_;
    msg_.create_db_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMsg::set_allocated_create_db_req(::hotbox::CreateDBReq* create_db_req) {
  clear_msg();
  if (create_db_req) {
    set_has_create_db_req();
    msg_.create_db_req_ = create_db_req;
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.ClientMsg.create_db_req)
}

// optional .hotbox.ReadFileReq read_file_req = 4;
inline bool ClientMsg::has_read_file_req() const {
  return msg_case() == kReadFileReq;
}
inline void ClientMsg::set_has_read_file_req() {
  _oneof_case_[0] = kReadFileReq;
}
inline void ClientMsg::clear_read_file_req() {
  if (has_read_file_req()) {
    delete msg_.read_file_req_;
    clear_has_msg();
  }
}
inline  const ::hotbox::ReadFileReq& ClientMsg::read_file_req() const {
  // @@protoc_insertion_point(field_get:hotbox.ClientMsg.read_file_req)
  return has_read_file_req()
      ? *msg_.read_file_req_
      : ::hotbox::ReadFileReq::default_instance();
}
inline ::hotbox::ReadFileReq* ClientMsg::mutable_read_file_req() {
  if (!has_read_file_req()) {
    clear_msg();
    set_has_read_file_req();
    msg_.read_file_req_ = new ::hotbox::ReadFileReq;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.ClientMsg.read_file_req)
  return msg_.read_file_req_;
}
inline ::hotbox::ReadFileReq* ClientMsg::release_read_file_req() {
  if (has_read_file_req()) {
    clear_has_msg();
    ::hotbox::ReadFileReq* temp = msg_.read_file_req_;
    msg_.read_file_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMsg::set_allocated_read_file_req(::hotbox::ReadFileReq* read_file_req) {
  clear_msg();
  if (read_file_req) {
    set_has_read_file_req();
    msg_.read_file_req_ = read_file_req;
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.ClientMsg.read_file_req)
}

// optional .hotbox.DBServerShutdownReq db_server_shutdown_req = 5;
inline bool ClientMsg::has_db_server_shutdown_req() const {
  return msg_case() == kDbServerShutdownReq;
}
inline void ClientMsg::set_has_db_server_shutdown_req() {
  _oneof_case_[0] = kDbServerShutdownReq;
}
inline void ClientMsg::clear_db_server_shutdown_req() {
  if (has_db_server_shutdown_req()) {
    delete msg_.db_server_shutdown_req_;
    clear_has_msg();
  }
}
inline  const ::hotbox::DBServerShutdownReq& ClientMsg::db_server_shutdown_req() const {
  // @@protoc_insertion_point(field_get:hotbox.ClientMsg.db_server_shutdown_req)
  return has_db_server_shutdown_req()
      ? *msg_.db_server_shutdown_req_
      : ::hotbox::DBServerShutdownReq::default_instance();
}
inline ::hotbox::DBServerShutdownReq* ClientMsg::mutable_db_server_shutdown_req() {
  if (!has_db_server_shutdown_req()) {
    clear_msg();
    set_has_db_server_shutdown_req();
    msg_.db_server_shutdown_req_ = new ::hotbox::DBServerShutdownReq;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.ClientMsg.db_server_shutdown_req)
  return msg_.db_server_shutdown_req_;
}
inline ::hotbox::DBServerShutdownReq* ClientMsg::release_db_server_shutdown_req() {
  if (has_db_server_shutdown_req()) {
    clear_has_msg();
    ::hotbox::DBServerShutdownReq* temp = msg_.db_server_shutdown_req_;
    msg_.db_server_shutdown_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMsg::set_allocated_db_server_shutdown_req(::hotbox::DBServerShutdownReq* db_server_shutdown_req) {
  clear_msg();
  if (db_server_shutdown_req) {
    set_has_db_server_shutdown_req();
    msg_.db_server_shutdown_req_ = db_server_shutdown_req;
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.ClientMsg.db_server_shutdown_req)
}

// optional .hotbox.CreateSessionReq create_session_req = 6;
inline bool ClientMsg::has_create_session_req() const {
  return msg_case() == kCreateSessionReq;
}
inline void ClientMsg::set_has_create_session_req() {
  _oneof_case_[0] = kCreateSessionReq;
}
inline void ClientMsg::clear_create_session_req() {
  if (has_create_session_req()) {
    delete msg_.create_session_req_;
    clear_has_msg();
  }
}
inline  const ::hotbox::CreateSessionReq& ClientMsg::create_session_req() const {
  // @@protoc_insertion_point(field_get:hotbox.ClientMsg.create_session_req)
  return has_create_session_req()
      ? *msg_.create_session_req_
      : ::hotbox::CreateSessionReq::default_instance();
}
inline ::hotbox::CreateSessionReq* ClientMsg::mutable_create_session_req() {
  if (!has_create_session_req()) {
    clear_msg();
    set_has_create_session_req();
    msg_.create_session_req_ = new ::hotbox::CreateSessionReq;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.ClientMsg.create_session_req)
  return msg_.create_session_req_;
}
inline ::hotbox::CreateSessionReq* ClientMsg::release_create_session_req() {
  if (has_create_session_req()) {
    clear_has_msg();
    ::hotbox::CreateSessionReq* temp = msg_.create_session_req_;
    msg_.create_session_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMsg::set_allocated_create_session_req(::hotbox::CreateSessionReq* create_session_req) {
  clear_msg();
  if (create_session_req) {
    set_has_create_session_req();
    msg_.create_session_req_ = create_session_req;
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.ClientMsg.create_session_req)
}

// optional .hotbox.CloseSessionReq close_session_req = 7;
inline bool ClientMsg::has_close_session_req() const {
  return msg_case() == kCloseSessionReq;
}
inline void ClientMsg::set_has_close_session_req() {
  _oneof_case_[0] = kCloseSessionReq;
}
inline void ClientMsg::clear_close_session_req() {
  if (has_close_session_req()) {
    delete msg_.close_session_req_;
    clear_has_msg();
  }
}
inline  const ::hotbox::CloseSessionReq& ClientMsg::close_session_req() const {
  // @@protoc_insertion_point(field_get:hotbox.ClientMsg.close_session_req)
  return has_close_session_req()
      ? *msg_.close_session_req_
      : ::hotbox::CloseSessionReq::default_instance();
}
inline ::hotbox::CloseSessionReq* ClientMsg::mutable_close_session_req() {
  if (!has_close_session_req()) {
    clear_msg();
    set_has_close_session_req();
    msg_.close_session_req_ = new ::hotbox::CloseSessionReq;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.ClientMsg.close_session_req)
  return msg_.close_session_req_;
}
inline ::hotbox::CloseSessionReq* ClientMsg::release_close_session_req() {
  if (has_close_session_req()) {
    clear_has_msg();
    ::hotbox::CloseSessionReq* temp = msg_.close_session_req_;
    msg_.close_session_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientMsg::set_allocated_close_session_req(::hotbox::CloseSessionReq* close_session_req) {
  clear_msg();
  if (close_session_req) {
    set_has_close_session_req();
    msg_.close_session_req_ = close_session_req;
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.ClientMsg.close_session_req)
}

inline bool ClientMsg::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void ClientMsg::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline ClientMsg::MsgCase ClientMsg::msg_case() const {
  return ClientMsg::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMsg

// optional .hotbox.ServerHandshake handshake_msg = 1;
inline bool ServerMsg::has_handshake_msg() const {
  return msg_case() == kHandshakeMsg;
}
inline void ServerMsg::set_has_handshake_msg() {
  _oneof_case_[0] = kHandshakeMsg;
}
inline void ServerMsg::clear_handshake_msg() {
  if (has_handshake_msg()) {
    delete msg_.handshake_msg_;
    clear_has_msg();
  }
}
inline  const ::hotbox::ServerHandshake& ServerMsg::handshake_msg() const {
  // @@protoc_insertion_point(field_get:hotbox.ServerMsg.handshake_msg)
  return has_handshake_msg()
      ? *msg_.handshake_msg_
      : ::hotbox::ServerHandshake::default_instance();
}
inline ::hotbox::ServerHandshake* ServerMsg::mutable_handshake_msg() {
  if (!has_handshake_msg()) {
    clear_msg();
    set_has_handshake_msg();
    msg_.handshake_msg_ = new ::hotbox::ServerHandshake;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.ServerMsg.handshake_msg)
  return msg_.handshake_msg_;
}
inline ::hotbox::ServerHandshake* ServerMsg::release_handshake_msg() {
  if (has_handshake_msg()) {
    clear_has_msg();
    ::hotbox::ServerHandshake* temp = msg_.handshake_msg_;
    msg_.handshake_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMsg::set_allocated_handshake_msg(::hotbox::ServerHandshake* handshake_msg) {
  clear_msg();
  if (handshake_msg) {
    set_has_handshake_msg();
    msg_.handshake_msg_ = handshake_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.ServerMsg.handshake_msg)
}

// optional .hotbox.GenericReply generic_reply = 2;
inline bool ServerMsg::has_generic_reply() const {
  return msg_case() == kGenericReply;
}
inline void ServerMsg::set_has_generic_reply() {
  _oneof_case_[0] = kGenericReply;
}
inline void ServerMsg::clear_generic_reply() {
  if (has_generic_reply()) {
    delete msg_.generic_reply_;
    clear_has_msg();
  }
}
inline  const ::hotbox::GenericReply& ServerMsg::generic_reply() const {
  // @@protoc_insertion_point(field_get:hotbox.ServerMsg.generic_reply)
  return has_generic_reply()
      ? *msg_.generic_reply_
      : ::hotbox::GenericReply::default_instance();
}
inline ::hotbox::GenericReply* ServerMsg::mutable_generic_reply() {
  if (!has_generic_reply()) {
    clear_msg();
    set_has_generic_reply();
    msg_.generic_reply_ = new ::hotbox::GenericReply;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.ServerMsg.generic_reply)
  return msg_.generic_reply_;
}
inline ::hotbox::GenericReply* ServerMsg::release_generic_reply() {
  if (has_generic_reply()) {
    clear_has_msg();
    ::hotbox::GenericReply* temp = msg_.generic_reply_;
    msg_.generic_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMsg::set_allocated_generic_reply(::hotbox::GenericReply* generic_reply) {
  clear_msg();
  if (generic_reply) {
    set_has_generic_reply();
    msg_.generic_reply_ = generic_reply;
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.ServerMsg.generic_reply)
}

// optional .hotbox.CreateSessionReply create_session_reply = 3;
inline bool ServerMsg::has_create_session_reply() const {
  return msg_case() == kCreateSessionReply;
}
inline void ServerMsg::set_has_create_session_reply() {
  _oneof_case_[0] = kCreateSessionReply;
}
inline void ServerMsg::clear_create_session_reply() {
  if (has_create_session_reply()) {
    delete msg_.create_session_reply_;
    clear_has_msg();
  }
}
inline  const ::hotbox::CreateSessionReply& ServerMsg::create_session_reply() const {
  // @@protoc_insertion_point(field_get:hotbox.ServerMsg.create_session_reply)
  return has_create_session_reply()
      ? *msg_.create_session_reply_
      : ::hotbox::CreateSessionReply::default_instance();
}
inline ::hotbox::CreateSessionReply* ServerMsg::mutable_create_session_reply() {
  if (!has_create_session_reply()) {
    clear_msg();
    set_has_create_session_reply();
    msg_.create_session_reply_ = new ::hotbox::CreateSessionReply;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.ServerMsg.create_session_reply)
  return msg_.create_session_reply_;
}
inline ::hotbox::CreateSessionReply* ServerMsg::release_create_session_reply() {
  if (has_create_session_reply()) {
    clear_has_msg();
    ::hotbox::CreateSessionReply* temp = msg_.create_session_reply_;
    msg_.create_session_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerMsg::set_allocated_create_session_reply(::hotbox::CreateSessionReply* create_session_reply) {
  clear_msg();
  if (create_session_reply) {
    set_has_create_session_reply();
    msg_.create_session_reply_ = create_session_reply;
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.ServerMsg.create_session_reply)
}

inline bool ServerMsg::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void ServerMsg::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline ServerMsg::MsgCase ServerMsg::msg_case() const {
  return ServerMsg::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerHandshake

// optional int32 client_id = 1;
inline void ServerHandshake::clear_client_id() {
  client_id_ = 0;
}
inline ::google::protobuf::int32 ServerHandshake::client_id() const {
  // @@protoc_insertion_point(field_get:hotbox.ServerHandshake.client_id)
  return client_id_;
}
inline void ServerHandshake::set_client_id(::google::protobuf::int32 value) {
  
  client_id_ = value;
  // @@protoc_insertion_point(field_set:hotbox.ServerHandshake.client_id)
}

// -------------------------------------------------------------------

// ClientHandshake

// optional bool dummy = 1;
inline void ClientHandshake::clear_dummy() {
  dummy_ = false;
}
inline bool ClientHandshake::dummy() const {
  // @@protoc_insertion_point(field_get:hotbox.ClientHandshake.dummy)
  return dummy_;
}
inline void ClientHandshake::set_dummy(bool value) {
  
  dummy_ = value;
  // @@protoc_insertion_point(field_set:hotbox.ClientHandshake.dummy)
}

// -------------------------------------------------------------------

// GenericRequest

// optional string req = 1;
inline void GenericRequest::clear_req() {
  req_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GenericRequest::req() const {
  // @@protoc_insertion_point(field_get:hotbox.GenericRequest.req)
  return req_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GenericRequest::set_req(const ::std::string& value) {
  
  req_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hotbox.GenericRequest.req)
}
inline void GenericRequest::set_req(const char* value) {
  
  req_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hotbox.GenericRequest.req)
}
inline void GenericRequest::set_req(const char* value, size_t size) {
  
  req_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hotbox.GenericRequest.req)
}
inline ::std::string* GenericRequest::mutable_req() {
  
  // @@protoc_insertion_point(field_mutable:hotbox.GenericRequest.req)
  return req_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GenericRequest::release_req() {
  
  return req_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GenericRequest::set_allocated_req(::std::string* req) {
  if (req != NULL) {
    
  } else {
    
  }
  req_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), req);
  // @@protoc_insertion_point(field_set_allocated:hotbox.GenericRequest.req)
}

// -------------------------------------------------------------------

// GenericReply

// optional string msg = 1;
inline void GenericReply::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GenericReply::msg() const {
  // @@protoc_insertion_point(field_get:hotbox.GenericReply.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GenericReply::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hotbox.GenericReply.msg)
}
inline void GenericReply::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hotbox.GenericReply.msg)
}
inline void GenericReply::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hotbox.GenericReply.msg)
}
inline ::std::string* GenericReply::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:hotbox.GenericReply.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GenericReply::release_msg() {
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GenericReply::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:hotbox.GenericReply.msg)
}

// -------------------------------------------------------------------

// CreateDBReq

// optional .hotbox.DBConfig db_config = 1;
inline bool CreateDBReq::has_db_config() const {
  return !_is_default_instance_ && db_config_ != NULL;
}
inline void CreateDBReq::clear_db_config() {
  if (GetArenaNoVirtual() == NULL && db_config_ != NULL) delete db_config_;
  db_config_ = NULL;
}
inline const ::hotbox::DBConfig& CreateDBReq::db_config() const {
  // @@protoc_insertion_point(field_get:hotbox.CreateDBReq.db_config)
  return db_config_ != NULL ? *db_config_ : *default_instance_->db_config_;
}
inline ::hotbox::DBConfig* CreateDBReq::mutable_db_config() {
  
  if (db_config_ == NULL) {
    db_config_ = new ::hotbox::DBConfig;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.CreateDBReq.db_config)
  return db_config_;
}
inline ::hotbox::DBConfig* CreateDBReq::release_db_config() {
  
  ::hotbox::DBConfig* temp = db_config_;
  db_config_ = NULL;
  return temp;
}
inline void CreateDBReq::set_allocated_db_config(::hotbox::DBConfig* db_config) {
  delete db_config_;
  db_config_ = db_config;
  if (db_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.CreateDBReq.db_config)
}

// -------------------------------------------------------------------

// ReadFileReq

// optional string db_name = 1;
inline void ReadFileReq::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadFileReq::db_name() const {
  // @@protoc_insertion_point(field_get:hotbox.ReadFileReq.db_name)
  return db_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadFileReq::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hotbox.ReadFileReq.db_name)
}
inline void ReadFileReq::set_db_name(const char* value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hotbox.ReadFileReq.db_name)
}
inline void ReadFileReq::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hotbox.ReadFileReq.db_name)
}
inline ::std::string* ReadFileReq::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:hotbox.ReadFileReq.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadFileReq::release_db_name() {
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadFileReq::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:hotbox.ReadFileReq.db_name)
}

// optional string file_path = 2;
inline void ReadFileReq::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadFileReq::file_path() const {
  // @@protoc_insertion_point(field_get:hotbox.ReadFileReq.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadFileReq::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hotbox.ReadFileReq.file_path)
}
inline void ReadFileReq::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hotbox.ReadFileReq.file_path)
}
inline void ReadFileReq::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hotbox.ReadFileReq.file_path)
}
inline ::std::string* ReadFileReq::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:hotbox.ReadFileReq.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadFileReq::release_file_path() {
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadFileReq::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:hotbox.ReadFileReq.file_path)
}

// optional .hotbox.FileFormat file_format = 3;
inline void ReadFileReq::clear_file_format() {
  file_format_ = 0;
}
inline ::hotbox::FileFormat ReadFileReq::file_format() const {
  // @@protoc_insertion_point(field_get:hotbox.ReadFileReq.file_format)
  return static_cast< ::hotbox::FileFormat >(file_format_);
}
inline void ReadFileReq::set_file_format(::hotbox::FileFormat value) {
  
  file_format_ = value;
  // @@protoc_insertion_point(field_set:hotbox.ReadFileReq.file_format)
}

// optional int32 header = 4;
inline void ReadFileReq::clear_header() {
  header_ = 0;
}
inline ::google::protobuf::int32 ReadFileReq::header() const {
  // @@protoc_insertion_point(field_get:hotbox.ReadFileReq.header)
  return header_;
}
inline void ReadFileReq::set_header(::google::protobuf::int32 value) {
  
  header_ = value;
  // @@protoc_insertion_point(field_set:hotbox.ReadFileReq.header)
}

// optional .hotbox.ParserConfig parser_config = 5;
inline bool ReadFileReq::has_parser_config() const {
  return !_is_default_instance_ && parser_config_ != NULL;
}
inline void ReadFileReq::clear_parser_config() {
  if (GetArenaNoVirtual() == NULL && parser_config_ != NULL) delete parser_config_;
  parser_config_ = NULL;
}
inline const ::hotbox::ParserConfig& ReadFileReq::parser_config() const {
  // @@protoc_insertion_point(field_get:hotbox.ReadFileReq.parser_config)
  return parser_config_ != NULL ? *parser_config_ : *default_instance_->parser_config_;
}
inline ::hotbox::ParserConfig* ReadFileReq::mutable_parser_config() {
  
  if (parser_config_ == NULL) {
    parser_config_ = new ::hotbox::ParserConfig;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.ReadFileReq.parser_config)
  return parser_config_;
}
inline ::hotbox::ParserConfig* ReadFileReq::release_parser_config() {
  
  ::hotbox::ParserConfig* temp = parser_config_;
  parser_config_ = NULL;
  return temp;
}
inline void ReadFileReq::set_allocated_parser_config(::hotbox::ParserConfig* parser_config) {
  delete parser_config_;
  parser_config_ = parser_config;
  if (parser_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.ReadFileReq.parser_config)
}

// -------------------------------------------------------------------

// DBServerShutdownReq

// -------------------------------------------------------------------

// CreateSessionReq

// optional .hotbox.SessionOptionsProto session_options = 1;
inline bool CreateSessionReq::has_session_options() const {
  return !_is_default_instance_ && session_options_ != NULL;
}
inline void CreateSessionReq::clear_session_options() {
  if (GetArenaNoVirtual() == NULL && session_options_ != NULL) delete session_options_;
  session_options_ = NULL;
}
inline const ::hotbox::SessionOptionsProto& CreateSessionReq::session_options() const {
  // @@protoc_insertion_point(field_get:hotbox.CreateSessionReq.session_options)
  return session_options_ != NULL ? *session_options_ : *default_instance_->session_options_;
}
inline ::hotbox::SessionOptionsProto* CreateSessionReq::mutable_session_options() {
  
  if (session_options_ == NULL) {
    session_options_ = new ::hotbox::SessionOptionsProto;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.CreateSessionReq.session_options)
  return session_options_;
}
inline ::hotbox::SessionOptionsProto* CreateSessionReq::release_session_options() {
  
  ::hotbox::SessionOptionsProto* temp = session_options_;
  session_options_ = NULL;
  return temp;
}
inline void CreateSessionReq::set_allocated_session_options(::hotbox::SessionOptionsProto* session_options) {
  delete session_options_;
  session_options_ = session_options;
  if (session_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.CreateSessionReq.session_options)
}

// -------------------------------------------------------------------

// CreateSessionReply

// optional string msg = 1;
inline void CreateSessionReply::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateSessionReply::msg() const {
  // @@protoc_insertion_point(field_get:hotbox.CreateSessionReply.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateSessionReply::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hotbox.CreateSessionReply.msg)
}
inline void CreateSessionReply::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hotbox.CreateSessionReply.msg)
}
inline void CreateSessionReply::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hotbox.CreateSessionReply.msg)
}
inline ::std::string* CreateSessionReply::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:hotbox.CreateSessionReply.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateSessionReply::release_msg() {
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateSessionReply::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:hotbox.CreateSessionReply.msg)
}

// optional .hotbox.StatusCode status_code = 2;
inline void CreateSessionReply::clear_status_code() {
  status_code_ = 0;
}
inline ::hotbox::StatusCode CreateSessionReply::status_code() const {
  // @@protoc_insertion_point(field_get:hotbox.CreateSessionReply.status_code)
  return static_cast< ::hotbox::StatusCode >(status_code_);
}
inline void CreateSessionReply::set_status_code(::hotbox::StatusCode value) {
  
  status_code_ = value;
  // @@protoc_insertion_point(field_set:hotbox.CreateSessionReply.status_code)
}

// optional .hotbox.SessionProto session_proto = 3;
inline bool CreateSessionReply::has_session_proto() const {
  return !_is_default_instance_ && session_proto_ != NULL;
}
inline void CreateSessionReply::clear_session_proto() {
  if (GetArenaNoVirtual() == NULL && session_proto_ != NULL) delete session_proto_;
  session_proto_ = NULL;
}
inline const ::hotbox::SessionProto& CreateSessionReply::session_proto() const {
  // @@protoc_insertion_point(field_get:hotbox.CreateSessionReply.session_proto)
  return session_proto_ != NULL ? *session_proto_ : *default_instance_->session_proto_;
}
inline ::hotbox::SessionProto* CreateSessionReply::mutable_session_proto() {
  
  if (session_proto_ == NULL) {
    session_proto_ = new ::hotbox::SessionProto;
  }
  // @@protoc_insertion_point(field_mutable:hotbox.CreateSessionReply.session_proto)
  return session_proto_;
}
inline ::hotbox::SessionProto* CreateSessionReply::release_session_proto() {
  
  ::hotbox::SessionProto* temp = session_proto_;
  session_proto_ = NULL;
  return temp;
}
inline void CreateSessionReply::set_allocated_session_proto(::hotbox::SessionProto* session_proto) {
  delete session_proto_;
  session_proto_ = session_proto;
  if (session_proto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:hotbox.CreateSessionReply.session_proto)
}

// -------------------------------------------------------------------

// CloseSessionReq

// optional string session_id = 1;
inline void CloseSessionReq::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloseSessionReq::session_id() const {
  // @@protoc_insertion_point(field_get:hotbox.CloseSessionReq.session_id)
  return session_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloseSessionReq::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hotbox.CloseSessionReq.session_id)
}
inline void CloseSessionReq::set_session_id(const char* value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hotbox.CloseSessionReq.session_id)
}
inline void CloseSessionReq::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hotbox.CloseSessionReq.session_id)
}
inline ::std::string* CloseSessionReq::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:hotbox.CloseSessionReq.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloseSessionReq::release_session_id() {
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloseSessionReq::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:hotbox.CloseSessionReq.session_id)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hotbox

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_util_2fproto_2fwarp_5fmsg_2eproto__INCLUDED
