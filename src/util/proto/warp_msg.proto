syntax = "proto3";

import "util/proto/util.proto";
import "schema/proto/schema.proto";
import "db/proto/db.proto";
import "parse/proto/parser_config.proto";

package hotbox;

// Union of all messages from client to server.
message ClientMsg {
  oneof msg {
    ClientHandshake handshake_msg = 1;
    GenericRequest generic_req = 2;
    CreateDBReq create_db_req = 3;
    ReadFileReq read_file_req = 4;
    DBServerShutdownReq db_server_shutdown_req = 5;
    CreateSessionReq create_session_req = 6;
    CloseSessionReq close_session_req = 7;

    // Request by proxy client only.
    ProxyCreateIterReq proxy_create_iter_req = 8;
    ProxyDestroyIterReq proxy_destroy_iter_req = 9;
    ProxyGetBatchReq proxy_get_batch_req = 10;
    ProxyRestartReq proxy_restart_req = 11;
  }
}

// Union of all messages from server to client.
message ServerMsg {
  oneof msg {
    ServerHandshake handshake_msg = 1;
    GenericReply generic_reply = 2;
    CreateSessionReply create_session_reply = 3;

    // Response by proxy server only.
    ProxyGetBatchReply proxy_get_batch_reply = 4;
  }
}

// The first part of server's reply msg contains server router socket's
// identity, so no need to include that.
message ServerHandshake {
  int32 client_id = 1;
}

message ClientHandshake {
  // python needs to set a field to instantiate ClientHandshake msg.
  bool dummy = 1;
}

message GenericRequest {
  string req = 1;
}

message GenericReply {
  string msg = 1;
}

message ProxyDataBatchReply {
}

message CreateDBReq {
  DBConfig db_config = 1;
}

message ReadFileReq {
  string db_name = 1;
  repeated string file_paths = 2;
  FileFormat file_format = 3;

  // Optional. If set, expand 'default' feature family to this many features.
  int64 num_features_default = 7;

  // True to commit stats and schema to disk (use false for all files but the
  // last one when ingesting multiple files to reduce disk io).
  bool commit = 6;

  // header is the line # to be treated as header (0 for no header). Data will
  // # be read after header line.
  // TODO(wdai): Support col_name:type_name in the first row (e.g.,
  // state:bytes).
  int32 header = 4;

  // optional configuration for parsing.
  ParserConfig parser_config = 5;
}

message DBServerShutdownReq {
}

message CreateSessionReq {
  SessionOptionsProto session_options = 1;
}

message CreateSessionReply {
  string msg = 1;
  StatusCode status_code = 2;
  SessionProto session_proto = 3;

  // Used between ProxyServer and proxy client. session_id are unique for a
  // ProxyServer.
  //
  // Comment(wdai): Since a ProxyServer could server multiple clients which
  // has multiple sessions, the session need to be identified by a session_id
  // generated by ProxyServer.
  //int32 session_id = 4;
}

message CloseSessionReq {
  string session_id = 1;
}

message ProxyCreateIterReq {
  string session_id = 1;
  int32 iter_id = 2;

  // NewDataIterator function arguments.
  int64 data_begin = 3;
  int64 data_end = 4;
  int32 num_transform_threads = 5;
  int32 num_io_threads = 6;
  uint64 buffer_limit = 7;
  uint64 batch_limit = 8;
}

message ProxyDestroyIterReq {
  string session_id = 1;
  int32 iter_id = 2;
}

message ProxyGetBatchReq {
  string session_id = 1;
  int32 iter_id = 2;
  int32 batch_size = 3;
}

message ProxyGetBatchReply {
  //repeated FlexiDatumProto data = 1;
  // Use bytes to bypass time-consuming encoding when transmitting over
  // inproc.
  repeated bytes data = 1;
}

message ProxyRestartReq {
  string session_id = 1;
  int32 iter_id = 2;
}
